//! Photo database module for facial recognition system
//! 
//! This module handles the storage and retrieval of customer photos in MongoDB.
//! It provides functionality to save photos as binary data and retrieve them
//! based on customer names or other criteria.

use mongodb::{Client, Database, Collection};
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};
use std::env;

/// Represents a customer photo stored in MongoDB
/// 
/// This struct stores information about a customer photo including:
/// - MongoDB ObjectId (optional, auto-generated by MongoDB)
/// - Customer name associated with the photo
/// - Binary photo data
/// - Creation timestamp
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct CustomerPhoto {
    /// MongoDB ObjectId for this document (auto-generated)
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<mongodb::bson::oid::ObjectId>,
    /// Name of the customer associated with this photo
    pub customer_name: String,
    /// Binary data of the photo (stored as Vec<u8>)
    pub photo_data: Vec<u8>,
    /// UTC timestamp indicating when this photo was created
    pub created_at: DateTime<Utc>,
}

impl CustomerPhoto {
    /// Create a new CustomerPhoto instance
    /// 
    /// # Arguments
    /// * `customer_name` - The name of the customer
    /// * `photo_data` - Binary data of the photo
    /// 
    /// # Returns
    /// A new CustomerPhoto instance with current timestamp and no ID
    pub fn new(customer_name: String, photo_data: Vec<u8>) -> Self {
        Self {
            // ID will be auto-generated by MongoDB when saved
            id: None,
            customer_name,
            photo_data,
            // Record the current UTC time
            created_at: Utc::now(),
        }
    }
}

/// Manages customer photos in MongoDB
/// 
/// This struct provides functionality to connect to MongoDB and perform
/// CRUD operations on customer photos. It maintains a reference to the
/// MongoDB collection where photos are stored.
pub struct PhotoDatabase {
    /// MongoDB collection for customer photos
    collection: Collection<CustomerPhoto>,
}

impl PhotoDatabase {
    /// Create a new PhotoDatabase instance
    /// 
    /// This function establishes a connection to MongoDB using either:
    /// 1. The MONGODB_URI environment variable
    /// 2. A default connection string (mongodb://localhost:27017)
    /// 
    /// It then connects to the "facial_recognition" database and
    /// "customer_photos" collection.
    /// 
    /// # Returns
    /// Result containing either a PhotoDatabase instance or a MongoDB error
    /// 
    /// # Errors
    /// Returns a MongoDB error if connection fails or if there are issues
    /// accessing the database or collection
    pub async fn new() -> Result<Self, mongodb::error::Error> {
        // Get MongoDB connection string from environment or use default
        let mongodb_uri = env::var("MONGODB_URI")
            .unwrap_or_else(|_| "mongodb://localhost:27017".to_string());
        
        // Create MongoDB client with the connection string
        let client = Client::with_uri_str(&mongodb_uri).await?;
        // Access the "facial_recognition" database
        let database: Database = client.database("facial_recognition");
        // Access the "customer_photos" collection
        let collection: Collection<CustomerPhoto> = database.collection("customer_photos");
        
        Ok(PhotoDatabase { collection })
    }
    
    /// Save a customer photo to MongoDB
    /// 
    /// This function inserts a new CustomerPhoto document into the MongoDB collection.
    /// MongoDB will automatically generate an ObjectId for the document.
    /// 
    /// # Arguments
    /// * `photo` - The CustomerPhoto to save
    /// 
    /// # Returns
    /// Result indicating success or failure of the operation
    /// 
    /// # Errors
    /// Returns a MongoDB error if there are issues inserting the document
    pub async fn save_customer_photo(&self, photo: CustomerPhoto) -> Result<(), mongodb::error::Error> {
        // Insert the photo document into the collection
        self.collection.insert_one(photo, None).await?;
        Ok(())
    }
    
    /// Retrieve customer photos by customer name
    /// 
    /// This function queries the MongoDB collection for all photos associated
    /// with a specific customer name.
    /// 
    /// # Arguments
    /// * `customer_name` - The name of the customer whose photos to retrieve
    /// 
    /// # Returns
    /// Result containing a vector of CustomerPhoto instances or a MongoDB error
    /// 
    /// # Errors
    /// Returns a MongoDB error if there are issues with the query or data retrieval
    pub async fn get_customer_photos(&self, customer_name: &str) -> Result<Vec<CustomerPhoto>, mongodb::error::Error> {
        use mongodb::bson::{doc, Document};
        use tokio_stream::StreamExt;
        
        // Create filter to find photos by customer name
        let filter = doc! { "customer_name": customer_name };
        // Execute the query and get a cursor
        let mut cursor = self.collection.find(filter, None).await?;
        
        // Collect all photos from the cursor
        let mut photos = Vec::new();
        while let Some(photo) = cursor.next().await {
            photos.push(photo?);
        }
        
        Ok(photos)
    }
    
    /// Retrieve all customer photos from MongoDB
    /// 
    /// This function queries the MongoDB collection for all photos stored in the database.
    /// 
    /// # Returns
    /// Result containing a vector of all CustomerPhoto instances or a MongoDB error
    /// 
    /// # Errors
    /// Returns a MongoDB error if there are issues with the query or data retrieval
    pub async fn get_all_photos(&self) -> Result<Vec<CustomerPhoto>, mongodb::error::Error> {
        use tokio_stream::StreamExt;
        
        // Execute query for all photos (no filter)
        let mut cursor = self.collection.find(None, None).await?;
        
        // Collect all photos from the cursor
        let mut photos = Vec::new();
        while let Some(photo) = cursor.next().await {
            photos.push(photo?);
        }
        
        Ok(photos)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::env;

    /// Test CustomerPhoto creation
    /// 
    /// This test verifies that:
    /// 1. A CustomerPhoto can be created with the correct customer name and photo data
    /// 2. The photo gets a None ID (will be assigned by MongoDB)
    /// 3. The photo gets a current timestamp
    #[test]
    fn test_customer_photo_creation() {
        // Create sample photo data (in a real scenario, this would be actual image bytes)
        let photo_data = vec![0u8, 1u8, 2u8, 3u8, 4u8];
        
        // Create a new CustomerPhoto
        let photo = CustomerPhoto::new("John Doe".to_string(), photo_data.clone());
        
        // Verify the photo was created with correct values
        assert!(photo.id.is_none()); // ID should be None initially
        assert_eq!(photo.customer_name, "John Doe");
        assert_eq!(photo.photo_data, photo_data);
        // Verify that the timestamp is recent (within the last minute)
        assert!(photo.created_at < Utc::now());
        assert!(photo.created_at > Utc::now() - chrono::Duration::minutes(1));
    }

    /// Test PhotoDatabase creation
    /// 
    /// This test verifies that:
    /// 1. A PhotoDatabase can be created with default MongoDB connection
    /// 2. A PhotoDatabase can be created with custom MongoDB connection from environment
    /// 
    /// Note: These tests require a running MongoDB instance and will fail in environments
    /// without it, but they demonstrate the expected behavior.
    #[tokio::test]
    async fn test_photo_database_creation() {
        // Test with default MongoDB connection
        // This will fail if MongoDB is not running locally on port 27017
        // In a real test environment, we would set up MongoDB properly or mock it
        let result = PhotoDatabase::new().await;
        // We can at least verify that the function compiles and returns a Result
        assert!(result.is_ok() || result.is_err());
    }

    /// Test PhotoDatabase save and retrieve operations
    /// 
    /// This test verifies that:
    /// 1. Customer photos can be saved to MongoDB
    /// 2. Customer photos can be retrieved by customer name
    /// 3. All customer photos can be retrieved
    /// 
    /// Note: This test requires a running MongoDB instance and will fail in environments
    /// without it, but it demonstrates the expected behavior.
    #[tokio::test]
    async fn test_photo_database_operations() {
        // Test with default MongoDB connection
        // This will fail if MongoDB is not running locally on port 27017
        // In a real test environment, we would set up MongoDB properly or mock it
        
        let result = PhotoDatabase::new().await;
        if result.is_ok() {
            let photo_db = result.unwrap();
            
            // Create sample photo data
            let photo_data = vec![0u8, 1u8, 2u8, 3u8, 4u8];
            
            // Create a new CustomerPhoto
            let photo = CustomerPhoto::new("Jane Smith".to_string(), photo_data);
            
            // Test saving a customer photo
            // This will fail if MongoDB is not running
            let save_result = photo_db.save_customer_photo(photo).await;
            assert!(save_result.is_ok() || save_result.is_err());
            
            // Test retrieving customer photos by name
            // This will fail if MongoDB is not running
            let photos_result = photo_db.get_customer_photos("Jane Smith").await;
            assert!(photos_result.is_ok() || photos_result.is_err());
            
            // Test retrieving all customer photos
            // This will fail if MongoDB is not running
            let all_photos_result = photo_db.get_all_photos().await;
            assert!(all_photos_result.is_ok() || all_photos_result.is_err());
        }
    }

    /// Test PhotoDatabase with custom MongoDB URI
    /// 
    /// This test verifies that:
    /// 1. A PhotoDatabase can be created with a custom MongoDB URI from environment
    /// 2. The custom URI is properly used for connection
    /// 
    /// Note: This test requires a running MongoDB instance and will fail in environments
    /// without it, but it demonstrates the expected behavior.
    #[tokio::test]
    async fn test_photo_database_custom_uri() {
        // Save the original MONGODB_URI value
        let original_uri = env::var("MONGODB_URI").ok();
        
        // Set a custom MongoDB URI for testing
        env::set_var("MONGODB_URI", "mongodb://localhost:27017");
        
        // Test with custom MongoDB connection
        // This will fail if MongoDB is not running on localhost:27017
        let result = PhotoDatabase::new().await;
        assert!(result.is_ok() || result.is_err());
        
        // Restore the original MONGODB_URI value
        match original_uri {
            Some(uri) => env::set_var("MONGODB_URI", uri),
            None => env::remove_var("MONGODB_URI"),
        }
    }

    /// Test PhotoDatabase error handling
    /// 
    /// This test verifies that:
    /// 1. Connection errors are properly handled when MongoDB is not accessible
    /// 2. Query errors are properly handled
    /// 
    /// Note: This test requires a specific setup to simulate connection errors
    /// and will not run in all environments, but it demonstrates the expected behavior.
    #[tokio::test]
    async fn test_photo_database_error_handling() {
        // Save the original MONGODB_URI value
        let original_uri = env::var("MONGODB_URI").ok();
        
        // Set an invalid MongoDB URI for testing error handling
        env::set_var("MONGODB_URI", "mongodb://invalid-host:27017");
        
        // Test with invalid MongoDB connection
        // This should return an error due to inability to connect
        let result = PhotoDatabase::new().await;
        // We can't predict the exact error type, but we can verify it returns an error
        assert!(result.is_err());
        
        // Restore the original MONGODB_URI value
        match original_uri {
            Some(uri) => env::set_var("MONGODB_URI", uri),
            None => env::remove_var("MONGODB_URI"),
        }
    }

    /// Test CustomerPhoto serialization and deserialization
    /// 
    /// This test verifies that:
    /// 1. CustomerPhoto instances can be serialized to JSON
    /// 2. CustomerPhoto instances can be deserialized from JSON
    /// 3. Serialization preserves all data correctly
    #[test]
    fn test_customer_photo_serialization() {
        // Create sample photo data
        let photo_data = vec![10u8, 20u8, 30u8, 40u8, 50u8];
        
        // Create a new CustomerPhoto
        let photo = CustomerPhoto::new("Serialization Test".to_string(), photo_data.clone());
        
        // Serialize to JSON
        let json = serde_json::to_string(&photo).unwrap();
        
        // Verify JSON contains expected fields
        assert!(json.contains("\"customer_name\":\"Serialization Test\""));
        assert!(json.contains("\"photo_data\":[10,20,30,40,50]"));
        assert!(json.contains("\"created_at\""));
        
        // Deserialize from JSON
        let deserialized: CustomerPhoto = serde_json::from_str(&json).unwrap();
        
        // Verify deserialized data matches original
        assert_eq!(deserialized.customer_name, photo.customer_name);
        assert_eq!(deserialized.photo_data, photo.photo_data);
        // Note: We can't directly compare timestamps due to serialization precision
        // but we can check they're reasonably close
        assert!((deserialized.created_at - photo.created_at).num_seconds().abs() < 2);
    }

    /// Test retrieving photos for non-existent customer
    /// 
    /// This test verifies that:
    /// 1. Retrieving photos for a non-existent customer returns an empty vector
    /// 2. No errors occur when querying for a non-existent customer
    /// 
    /// Note: This test requires a running MongoDB instance and will fail in environments
    /// without it, but it demonstrates the expected behavior.
    #[tokio::test]
    async fn test_photo_database_non_existent_customer() {
        // Test with default MongoDB connection
        let result = PhotoDatabase::new().await;
        if result.is_ok() {
            let photo_db = result.unwrap();
            
            // Test retrieving photos for a non-existent customer
            // This should return an empty vector, not an error
            let photos_result = photo_db.get_customer_photos("NonExistentCustomer").await;
            if let Ok(photos) = photos_result {
                assert_eq!(photos.len(), 0);
            }
        }
    }

    /// Test saving multiple photos for the same customer
    /// 
    /// This test verifies that:
    /// 1. Multiple photos can be saved for the same customer
    /// 2. All photos for a customer can be retrieved
    /// 3. Each photo gets a unique ID from MongoDB
    /// 
    /// Note: This test requires a running MongoDB instance and will fail in environments
    /// without it, but it demonstrates the expected behavior.
    #[tokio::test]
    async fn test_photo_database_multiple_photos() {
        // Test with default MongoDB connection
        let result = PhotoDatabase::new().await;
        if result.is_ok() {
            let photo_db = result.unwrap();
            
            // Create sample photo data for multiple photos
            let photo_data1 = vec![1u8, 2u8, 3u8];
            let photo_data2 = vec![4u8, 5u8, 6u8];
            let photo_data3 = vec![7u8, 8u8, 9u8];
            
            // Create multiple CustomerPhoto instances for the same customer
            let photos = vec![
                CustomerPhoto::new("Multi Photo Customer".to_string(), photo_data1),
                CustomerPhoto::new("Multi Photo Customer".to_string(), photo_data2),
                CustomerPhoto::new("Multi Photo Customer".to_string(), photo_data3),
            ];
            
            // Test saving multiple photos
            // This will fail if MongoDB is not running
            for photo in photos {
                let save_result = photo_db.save_customer_photo(photo).await;
                assert!(save_result.is_ok() || save_result.is_err());
            }
            
            // Test retrieving all photos for the customer
            // This will fail if MongoDB is not running
            let photos_result = photo_db.get_customer_photos("Multi Photo Customer").await;
            if let Ok(retrieved_photos) = photos_result {
                // Should have at least 3 photos (could be more if previous tests added photos)
                assert!(retrieved_photos.len() >= 3);
                
                // Verify all photos belong to the correct customer
                for photo in retrieved_photos {
                    assert_eq!(photo.customer_name, "Multi Photo Customer");
                    assert!(photo.id.is_some()); // Each photo should have an ID assigned by MongoDB
                }
            }
        }
    }
}