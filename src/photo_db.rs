//! Photo database module for facial recognition system
//!
//! This module handles the storage and retrieval of customer photos in SQLite.
//! It provides functionality to save photos as binary data and retrieve them
//! based on customer names or other criteria.

use chrono::{DateTime, Utc};
use rusqlite::{params, Connection};
use serde::{Deserialize, Serialize};
use std::fs;

/// Represents a customer photo stored in SQLite
///
/// This struct stores information about a customer photo including:
/// - Unique identifier for this photo record
/// - Customer name associated with the photo
/// - Binary photo data
/// - Creation timestamp
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct CustomerPhoto {
    /// Unique identifier for this photo record
    #[serde(rename = "id")]
    pub id: Option<i32>,
    /// Name of the customer associated with this photo
    pub customer_name: String,
    /// Binary data of the photo (stored as Vec<u8>)
    pub photo_data: Vec<u8>,
    /// UTC timestamp indicating when this photo was created
    pub created_at: DateTime<Utc>,
}

impl CustomerPhoto {
    /// Create a new CustomerPhoto instance
    ///
    /// # Arguments
    /// * `customer_name` - The name of the customer
    /// * `photo_data` - Binary data of the photo
    ///
    /// # Returns
    /// A new CustomerPhoto instance with current timestamp and no ID
    pub fn new(customer_name: String, photo_data: Vec<u8>) -> Self {
        Self {
            // ID will be auto-generated by SQLite when saved
            id: None,
            customer_name,
            photo_data,
            // Record the current UTC time
            created_at: Utc::now(),
        }
    }
}

/// Manages customer photos in SQLite
///
/// This struct provides functionality to connect to SQLite and perform
/// CRUD operations on customer photos. It maintains a reference to the
/// SQLite connection where photos are stored.
pub struct PhotoDatabase {
    /// SQLite connection for customer photos
    connection: Connection,
}

impl PhotoDatabase {
    /// Create a new PhotoDatabase instance
    ///
    /// This function establishes a connection to SQLite and creates
    /// the necessary tables if they don't exist.
    ///
    /// # Returns
    /// Result containing either a PhotoDatabase instance or a SQLite error
    ///
    /// # Errors
    /// Returns a SQLite error if connection fails or if there are issues
    /// accessing the database
    pub fn new() -> Result<Self, Box<dyn std::error::Error>> {
        // Create database directory if it doesn't exist
        fs::create_dir_all("database")?;

        // Connect to SQLite database
        let connection = Connection::open("database/customer_photos.db")?;

        // Create customer_photos table if it doesn't exist
        connection
            .execute(
                "CREATE TABLE IF NOT EXISTS customer_photos (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                customer_name TEXT NOT NULL,
                photo_data BLOB NOT NULL,
                created_at TEXT NOT NULL
            )",
                [],
            )
            .map_err(|e| Box::new(e) as Box<dyn std::error::Error>)?;

        Ok(PhotoDatabase { connection })
    }

    /// Save a customer photo to SQLite
    ///
    /// This function inserts a new CustomerPhoto record into the SQLite table.
    /// SQLite will automatically generate an ID for the record.
    ///
    /// # Arguments
    /// * `photo` - The CustomerPhoto to save
    ///
    /// # Returns
    /// Result indicating success or failure of the operation
    ///
    /// # Errors
    /// Returns a SQLite error if there are issues inserting the record
    pub fn save_customer_photo(
        &self,
        photo: CustomerPhoto,
    ) -> Result<(), Box<dyn std::error::Error>> {
        // Convert DateTime to string for storage
        let created_at_str = photo.created_at.to_rfc3339();

        // Insert the photo record into the table
        self.connection
            .execute(
                "INSERT INTO customer_photos (customer_name, photo_data, created_at)
             VALUES (?1, ?2, ?3)",
                params![photo.customer_name, photo.photo_data, created_at_str],
            )
            .map_err(|e| Box::new(e) as Box<dyn std::error::Error>)?;

        Ok(())
    }

    /// Retrieve customer photos by customer name
    ///
    /// This function queries the SQLite table for all photos associated
    /// with a specific customer name.
    ///
    /// # Arguments
    /// * `customer_name` - The name of the customer whose photos to retrieve
    ///
    /// # Returns
    /// Result containing a vector of CustomerPhoto instances or a SQLite error
    ///
    /// # Errors
    /// Returns a SQLite error if there are issues with the query or data retrieval
    pub fn get_customer_photos(
        &self,
        customer_name: &str,
    ) -> Result<Vec<CustomerPhoto>, Box<dyn std::error::Error>> {
        let mut stmt = self.connection.prepare(
            "SELECT id, customer_name, photo_data, created_at FROM customer_photos 
             WHERE customer_name = ?1",
        )?;

        let photo_iter = stmt.query_map(params![customer_name], |row| {
            let id: i32 = row.get(0)?;
            let customer_name: String = row.get(1)?;
            let photo_data: Vec<u8> = row.get(2)?;
            let created_at_str: String = row.get(3)?;
            let created_at = DateTime::parse_from_rfc3339(&created_at_str)
                .map_err(|_| rusqlite::Error::InvalidQuery)
                .map(|dt| dt.with_timezone(&Utc))?;
            
            Ok(CustomerPhoto {
                id: Some(id),
                customer_name,
                photo_data,
                created_at,
            })
        }).map_err(|e| Box::new(e) as Box<dyn std::error::Error>)?;

        let mut photos = Vec::new();
        for photo_result in photo_iter {
            photos.push(photo_result?);
        }

        Ok(photos)
    }

    /// Retrieve all customer photos from SQLite
    ///
    /// This function queries the SQLite table for all photos stored in the database.
    ///
    /// # Returns
    /// Result containing a vector of all CustomerPhoto instances or a SQLite error
    ///
    /// # Errors
    /// Returns a SQLite error if there are issues with the query or data retrieval
    pub fn get_all_photos(&self) -> Result<Vec<CustomerPhoto>, Box<dyn std::error::Error>> {
        let mut stmt = self
            .connection
            .prepare("SELECT id, customer_name, photo_data, created_at FROM customer_photos")?;

        let photo_iter = stmt
            .query_map(params![], |row| {
                let id: i32 = row.get(0)?;
                let customer_name: String = row.get(1)?;
                let photo_data: Vec<u8> = row.get(2)?;
                let created_at_str: String = row.get(3)?;
                let created_at = DateTime::parse_from_rfc3339(&created_at_str)
                    .map_err(|_| rusqlite::Error::InvalidQuery)
                    .map(|dt| dt.with_timezone(&Utc))?;
                
                Ok(CustomerPhoto {
                    id: Some(id),
                    customer_name,
                    photo_data,
                    created_at,
                })
            })
            .map_err(|e| Box::new(e) as Box<dyn std::error::Error>)?;

        let mut photos = Vec::new();
        for photo_result in photo_iter {
            photos.push(photo_result?);
        }

        Ok(photos)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::Utc;
    use std::fs;
    use std::path::Path;

    /// Test CustomerPhoto creation
    ///
    /// This test verifies that:
    /// 1. A CustomerPhoto can be created with the correct customer name and photo data
    /// 2. The photo gets a None ID (will be assigned by SQLite)
    /// 3. The photo gets a current timestamp
    #[test]
    fn test_customer_photo_creation() {
        // Create sample photo data (in a real scenario, this would be actual image bytes)
        let photo_data = vec![0u8, 1u8, 2u8, 3u8, 4u8];

        // Create a new CustomerPhoto
        let photo = CustomerPhoto::new("John Doe".to_string(), photo_data.clone());

        // Verify the photo was created with correct values
        assert!(photo.id.is_none()); // ID should be None initially
        assert_eq!(photo.customer_name, "John Doe");
        assert_eq!(photo.photo_data, photo_data);
        // Verify that the timestamp is recent (within the last minute)
        assert!(photo.created_at < Utc::now());
        assert!(photo.created_at > Utc::now() - chrono::Duration::minutes(1));
    }

    /// Test PhotoDatabase creation
    ///
    /// This test verifies that:
    /// 1. A PhotoDatabase can be created with SQLite connection
    /// 2. The necessary tables are created
    #[test]
    fn test_photo_database_creation() {
        // Clean up any existing test database
        let test_db_path = "database/test_photos.db";
        if Path::new(test_db_path).exists() {
            let _ = fs::remove_file(test_db_path);
        }

        // Test creating new database
        let photo_db = PhotoDatabase::new();
        assert!(photo_db.is_ok());

        // Clean up test database
        if Path::new(test_db_path).exists() {
            let _ = fs::remove_file(test_db_path);
        }
    }

    /// Test PhotoDatabase save and retrieve operations
    ///
    /// This test verifies that:
    /// 1. Customer photos can be saved to SQLite
    /// 2. Customer photos can be retrieved by customer name
    /// 3. All customer photos can be retrieved
    #[test]
    fn test_photo_database_operations() {
        // Clean up any existing test database
        let test_db_path = "database/test_operations.db";
        if Path::new(test_db_path).exists() {
            let _ = fs::remove_file(test_db_path);
        }

        // Create a new database for testing
        fs::create_dir_all("database").unwrap();
        let connection = Connection::open(test_db_path).unwrap();
        connection
            .execute(
                "CREATE TABLE IF NOT EXISTS customer_photos (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                customer_name TEXT NOT NULL,
                photo_data BLOB NOT NULL,
                created_at TEXT NOT NULL
            )",
                [],
            )
            .unwrap();

        let photo_db = PhotoDatabase { connection };

        // Create sample photo data
        let photo_data = vec![0u8, 1u8, 2u8, 3u8, 4u8];

        // Create a new CustomerPhoto
        let photo = CustomerPhoto::new("Jane Smith".to_string(), photo_data);

        // Test saving a customer photo
        let save_result = photo_db.save_customer_photo(photo);
        assert!(save_result.is_ok());

        // Test retrieving customer photos by name
        let photos_result = photo_db.get_customer_photos("Jane Smith");
        assert!(photos_result.is_ok());
        let photos = photos_result.unwrap();
        assert_eq!(photos.len(), 1);
        assert_eq!(photos[0].customer_name, "Jane Smith");

        // Test retrieving all customer photos
        let all_photos_result = photo_db.get_all_photos();
        assert!(all_photos_result.is_ok());
        let all_photos = all_photos_result.unwrap();
        assert!(!all_photos.is_empty());

        // Clean up test database
        if Path::new(test_db_path).exists() {
            let _ = fs::remove_file(test_db_path);
        }
    }

    /// Test CustomerPhoto serialization and deserialization
    ///
    /// This test verifies that:
    /// 1. CustomerPhoto instances can be serialized to JSON
    /// 2. CustomerPhoto instances can be deserialized from JSON
    /// 3. Serialization preserves all data correctly
    #[test]
    fn test_customer_photo_serialization() {
        // Create sample photo data
        let photo_data = vec![10u8, 20u8, 30u8, 40u8, 50u8];

        // Create a new CustomerPhoto
        let photo = CustomerPhoto::new("Serialization Test".to_string(), photo_data.clone());

        // Serialize to JSON
        let json = serde_json::to_string(&photo).unwrap();

        // Verify JSON contains expected fields
        assert!(json.contains("\"customer_name\":\"Serialization Test\""));
        assert!(json.contains("\"photo_data\":[10,20,30,40,50]"));
        assert!(json.contains("\"created_at\""));

        // Deserialize from JSON
        let deserialized: CustomerPhoto = serde_json::from_str(&json).unwrap();

        // Verify deserialized data matches original
        assert_eq!(deserialized.customer_name, photo.customer_name);
        assert_eq!(deserialized.photo_data, photo.photo_data);
        // Note: We can't directly compare timestamps due to serialization precision
        // but we can check they're reasonably close
        assert!(
            (deserialized.created_at - photo.created_at)
                .num_seconds()
                .abs()
                < 2
        );
    }

    /// Test retrieving photos for non-existent customer
    ///
    /// This test verifies that:
    /// 1. Retrieving photos for a non-existent customer returns an empty vector
    /// 2. No errors occur when querying for a non-existent customer
    #[test]
    fn test_photo_database_non_existent_customer() {
        // Clean up any existing test database
        let test_db_path = "database/test_non_existent.db";
        if Path::new(test_db_path).exists() {
            let _ = fs::remove_file(test_db_path);
        }

        // Create a new database for testing
        fs::create_dir_all("database").unwrap();
        let connection = Connection::open(test_db_path).unwrap();
        connection
            .execute(
                "CREATE TABLE IF NOT EXISTS customer_photos (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                customer_name TEXT NOT NULL,
                photo_data BLOB NOT NULL,
                created_at TEXT NOT NULL
            )",
                [],
            )
            .unwrap();

        let photo_db = PhotoDatabase { connection };

        // Test retrieving photos for a non-existent customer
        // This should return an empty vector, not an error
        let photos_result = photo_db.get_customer_photos("NonExistentCustomer");
        assert!(photos_result.is_ok());
        let photos = photos_result.unwrap();
        assert_eq!(photos.len(), 0);

        // Clean up test database
        if Path::new(test_db_path).exists() {
            let _ = fs::remove_file(test_db_path);
        }
    }

    /// Test saving multiple photos for the same customer
    ///
    /// This test verifies that:
    /// 1. Multiple photos can be saved for the same customer
    /// 2. All photos for a customer can be retrieved
    /// 3. Each photo gets a unique ID from SQLite
    #[test]
    fn test_photo_database_multiple_photos() {
        // Clean up any existing test database
        let test_db_path = "database/test_multiple.db";
        if Path::new(test_db_path).exists() {
            let _ = fs::remove_file(test_db_path);
        }

        // Create a new database for testing
        fs::create_dir_all("database").unwrap();
        let connection = Connection::open(test_db_path).unwrap();
        connection
            .execute(
                "CREATE TABLE IF NOT EXISTS customer_photos (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                customer_name TEXT NOT NULL,
                photo_data BLOB NOT NULL,
                created_at TEXT NOT NULL
            )",
                [],
            )
            .unwrap();

        let photo_db = PhotoDatabase { connection };

        // Create sample photo data for multiple photos
        let photo_data1 = vec![1u8, 2u8, 3u8];
        let photo_data2 = vec![4u8, 5u8, 6u8];
        let photo_data3 = vec![7u8, 8u8, 9u8];

        // Create multiple CustomerPhoto instances for the same customer
        let photos = vec![
            CustomerPhoto::new("Multi Photo Customer".to_string(), photo_data1),
            CustomerPhoto::new("Multi Photo Customer".to_string(), photo_data2),
            CustomerPhoto::new("Multi Photo Customer".to_string(), photo_data3),
        ];

        // Test saving multiple photos
        for photo in photos {
            let save_result = photo_db.save_customer_photo(photo);
            assert!(save_result.is_ok());
        }

        // Test retrieving all photos for the customer
        let photos_result = photo_db.get_customer_photos("Multi Photo Customer");
        assert!(photos_result.is_ok());
        let retrieved_photos = photos_result.unwrap();
        // Should have at least 3 photos
        assert!(retrieved_photos.len() >= 3);

        // Verify all photos belong to the correct customer
        for photo in retrieved_photos {
            assert_eq!(photo.customer_name, "Multi Photo Customer");
            assert!(photo.id.is_some()); // Each photo should have an ID assigned by SQLite
        }

        // Clean up test database
        if Path::new(test_db_path).exists() {
            let _ = fs::remove_file(test_db_path);
        }
    }
}
